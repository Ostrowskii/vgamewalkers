{
  "version": 3,
  "sources": ["../../src/config.ts", "../../src/client.ts", "../../src/vibi.ts", "../../package.json", "../index.ts"],
  "sourcesContent": ["const REMOTE_WSS = \"wss://game.vibistudiotest.site\";\n\nfunction has_window(): boolean {\n  return typeof window !== \"undefined\" && typeof window.location !== \"undefined\";\n}\n\nfunction from_global_override(): string | undefined {\n  if (!has_window()) return undefined;\n  const global_any = window as typeof window & { __VIBI_WS_URL__?: string };\n  if (typeof global_any.__VIBI_WS_URL__ === \"string\") {\n    return global_any.__VIBI_WS_URL__;\n  }\n  return undefined;\n}\n\nfunction normalize(value: string): string {\n  if (value.startsWith(\"wss://\")) {\n    return value;\n  }\n  if (value.startsWith(\"ws://\")) {\n    return `wss://${value.slice(\"ws://\".length)}`;\n  }\n  return `wss://${value}`;\n}\n\nfunction from_query_param(): string | undefined {\n  if (!has_window()) return undefined;\n  try {\n    const url = new URL(window.location.href);\n    const value = url.searchParams.get(\"ws\");\n    if (value) {\n      return normalize(value);\n    }\n  } catch {\n    // ignore malformed URLs\n  }\n  return undefined;\n}\n\nfunction detect_url(): string {\n  const manual = from_global_override() ?? from_query_param();\n  if (manual) {\n    return manual;\n  }\n  return REMOTE_WSS;\n}\n\nexport const WS_URL = detect_url();\nexport const DEFAULT_REMOTE_WS = REMOTE_WSS;\n", "type TimeSync = {\n  clock_offset: number;     // difference between server clock and local clock\n  lowest_ping: number;      // best round-trip time achieved so far\n  request_sent_at: number;  // timestamp when last get_time request was sent\n  last_ping: number;        // most recent measured RTT (ms)\n};\n\nconst time_sync: TimeSync = {\n  clock_offset: Infinity,\n  lowest_ping: Infinity,\n  request_sent_at: 0,\n  last_ping: Infinity,\n};\n\nimport { WS_URL } from \"./config.ts\";\n\nconst ws = new WebSocket(WS_URL);\n\ntype MessageHandler = (message: any) => void;\nconst room_watchers = new Map<string, MessageHandler>();\n\nlet is_synced = false;\nconst sync_listeners: Array<() => void> = [];\n\nfunction now(): number {\n  return Math.floor(Date.now());\n}\n\nexport function server_time(): number {\n  if (!isFinite(time_sync.clock_offset)) {\n    throw new Error(\"server_time() called before initial sync\");\n  }\n  return Math.floor(now() + time_sync.clock_offset);\n}\n\nfunction ensure_open(): void {\n  if (ws.readyState !== WebSocket.OPEN) {\n    throw new Error(\"WebSocket not open\");\n  }\n}\n\nexport function send(obj: any): void {\n  ensure_open();\n  ws.send(JSON.stringify(obj));\n}\n\nfunction register_handler(room: string, handler?: MessageHandler): void {\n  if (!handler) {\n    return;\n  }\n\n  if (room_watchers.has(room)) {\n    throw new Error(`Handler already registered for room: ${room}`);\n  }\n\n  room_watchers.set(room, handler);\n}\n\nws.addEventListener(\"open\", () => {\n  console.log(\"[WS] Connected\");\n  time_sync.request_sent_at = now();\n  ws.send(JSON.stringify({ $: \"get_time\" }));\n  setInterval(() => {\n    time_sync.request_sent_at = now();\n    ws.send(JSON.stringify({ $: \"get_time\" }));\n  }, 2000);\n});\n\nws.addEventListener(\"message\", (event) => {\n  const msg = JSON.parse(event.data);\n\n  switch (msg.$) {\n    case \"info_time\": {\n      const t    = now();\n      const ping = t - time_sync.request_sent_at;\n\n      time_sync.last_ping = ping;\n\n      if (ping < time_sync.lowest_ping) {\n        const local_avg    = Math.floor((time_sync.request_sent_at + t) / 2);\n        time_sync.clock_offset = msg.time - local_avg;\n        time_sync.lowest_ping  = ping;\n      }\n\n      if (!is_synced) {\n        is_synced = true;\n        for (const cb of sync_listeners) {\n          cb();\n        }\n        sync_listeners.length = 0;\n      }\n      break;\n    }\n\n    case \"info_post\": {\n      const handler = room_watchers.get(msg.room);\n      if (handler) {\n        handler(msg);\n      }\n      break;\n    }\n  }\n});\n\n// API\nexport function gen_name(): string {\n  const alphabet   = \"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-\";\n  const bytes      = new Uint8Array(8);\n  const can_crypto = typeof crypto !== \"undefined\" && typeof crypto.getRandomValues === \"function\";\n\n  if (can_crypto) {\n    crypto.getRandomValues(bytes);\n  } else {\n    for (let i = 0; i < 8; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n\n  let out = \"\";\n  for (let i = 0; i < 8; i++) {\n    out += alphabet[bytes[i] % 64];\n  }\n\n  return out;\n}\n\nexport function post(room: string, data: any): string {\n  const name = gen_name();\n  send({ $: \"post\", room, time: server_time(), name, data });\n  return name;\n}\n\nexport function load(room: string, from: number = 0, handler?: MessageHandler): void {\n  register_handler(room, handler);\n  send({ $: \"load\", room, from });\n}\n\nexport function watch(room: string, handler?: MessageHandler): void {\n  register_handler(room, handler);\n  send({ $: \"watch\", room });\n}\n\nexport function unwatch(room: string): void {\n  room_watchers.delete(room);\n  send({ $: \"unwatch\", room });\n}\n\nexport function close(): void {\n  ws.close();\n}\n\nexport function on_sync(callback: () => void): void {\n  if (is_synced) {\n    callback();\n    return;\n  }\n  sync_listeners.push(callback);\n}\n\nexport function ping(): number {\n  return time_sync.last_ping;\n}\n", "import * as client from \"./client.ts\";\n\ntype Post<P> = {\n  room: string;\n  index: number;\n  server_time: number;\n  client_time: number;\n  name?: string; // unique id for dedup/reindex (optional for legacy)\n  data: P;\n};\n\nexport class Vibi<S, P> {\n  room:        string;\n  init:        S;\n  on_tick:     (state: S) => S;\n  on_post:     (post: P, state: S) => S;\n  smooth:      (past: S, curr: S) => S;\n  tick_rate:   number;\n  tolerance:   number;\n  room_posts:  Map<number, Post<P>>;\n  local_posts: Map<string, Post<P>>; // predicted local posts keyed by name\n  state_cache: S[];                  // cached states keyed by tick offset\n  cache_start: number | null;        // tick corresponding to state_cache[0]\n  timeline:    Map<number, Post<P>[]> | null; // cached timeline of posts per tick\n\n  // Compute the authoritative time a post takes effect.\n  private official_time(post: Post<P>): number {\n    if (post.client_time <= post.server_time - this.tolerance) {\n      return post.server_time - this.tolerance;\n    } else {\n      return post.client_time;\n    }\n  }\n\n  // Convert a post into its authoritative tick.\n  private official_tick(post: Post<P>): number {\n    return this.time_to_tick(this.official_time(post));\n  }\n\n  // Reset all cached states.\n  private reset_cache(): void {\n    this.state_cache.length = 0;\n    this.cache_start = null;\n  }\n\n  // Drop cached states from the provided tick (inclusive) onward.\n  private invalidate_cache(from_tick: number): void {\n    this.invalidate_timeline();\n\n    if (this.cache_start === null) {\n      return;\n    }\n\n    const drop_from = from_tick - this.cache_start;\n    if (drop_from <= 0) {\n      this.reset_cache();\n      return;\n    }\n\n    if (drop_from < this.state_cache.length) {\n      this.state_cache.length = drop_from;\n    }\n  }\n\n  // Invalidate the cached timeline so it will be rebuilt lazily.\n  private invalidate_timeline(): void {\n    this.timeline = null;\n  }\n\n  constructor(\n    room:      string,\n    init:      S,\n    on_tick:   (state: S) => S,\n    on_post:   (post: P, state: S) => S,\n    smooth:    (past: S, curr: S) => S,\n    tick_rate: number,\n    tolerance: number\n  ) {\n    this.room        = room;\n    this.init        = init;\n    this.on_tick     = on_tick;\n    this.on_post     = on_post;\n    this.smooth      = smooth;\n    this.tick_rate   = tick_rate;\n    this.tolerance   = tolerance;\n    this.room_posts  = new Map();\n    this.local_posts = new Map();\n    this.state_cache = [];\n    this.cache_start = null;\n    this.timeline    = null;\n\n    // Wait for initial time sync before interacting with server\n    client.on_sync(() => {\n      console.log(`[VIBI] synced; watching+loading room=${this.room}`);\n      // Watch the room with callback\n      client.watch(this.room, (post) => {\n        const official_tick = this.official_tick(post);\n\n        // If this official post matches a local predicted one, drop the local copy\n        if (post.name && this.local_posts.has(post.name)) {\n          this.local_posts.delete(post.name);\n        }\n        this.room_posts.set(post.index, post);\n        this.invalidate_cache(official_tick);\n      });\n\n      // Load all existing posts\n      client.load(this.room, 0);\n    });\n  }\n\n  // No extra helpers needed with local_posts: simplicity preserved\n\n  time_to_tick(server_time: number): number {\n    return Math.floor((server_time * this.tick_rate) / 1000);\n  }\n\n  server_time(): number {\n    return client.server_time();\n  }\n\n  server_tick(): number {\n    return this.time_to_tick(this.server_time());\n  }\n\n  // Total official posts loaded for this room\n  post_count(): number {\n    return this.room_posts.size;\n  }\n\n  // Compute a render-ready state by blending authoritative past and current\n  // using the provided smooth(past, curr) function.\n  compute_render_state(): S {\n    const curr_tick  = this.server_tick();\n    const tick_ms    = 1000 / this.tick_rate;\n    const tol_ticks  = Math.ceil(this.tolerance / tick_ms);\n    const rtt_ms     = client.ping();\n    const half_rtt   = isFinite(rtt_ms) ? Math.ceil((rtt_ms / 2) / tick_ms) : 0;\n    const past_ticks = Math.max(tol_ticks, half_rtt + 1);\n    const past_tick  = Math.max(0, curr_tick - past_ticks);\n\n    const past_state = this.compute_state_at(past_tick);\n    const curr_state = this.compute_state_at(curr_tick);\n\n    return this.smooth(past_state, curr_state);\n  }\n\n  initial_time(): number | null {\n    const post = this.room_posts.get(0);\n    if (!post) {\n      return null;\n    }\n    return this.official_time(post);\n  }\n\n  initial_tick(): number | null {\n    const t = this.initial_time();\n    if (t === null) {\n      return null;\n    }\n    return this.time_to_tick(t);\n  }\n\n  private build_timeline(): Map<number, Post<P>[]> {\n    if (this.timeline) {\n      return this.timeline;\n    }\n\n    const timeline = new Map<number, Post<P>[]>();\n\n    for (const post of this.room_posts.values()) {\n      const official_tick = this.official_tick(post);\n      if (!timeline.has(official_tick)) {\n        timeline.set(official_tick, []);\n      }\n      timeline.get(official_tick)!.push(post);\n    }\n\n    for (const post of this.local_posts.values()) {\n      const official_tick = this.official_tick(post);\n      if (!timeline.has(official_tick)) {\n        timeline.set(official_tick, []);\n      }\n      const local_queued: Post<P> = { ...post, index: Number.MAX_SAFE_INTEGER };\n      timeline.get(official_tick)!.push(local_queued);\n    }\n\n    for (const posts of timeline.values()) {\n      posts.sort((a, b) => a.index - b.index);\n    }\n\n    this.timeline = timeline;\n    return timeline;\n  }\n\n  compute_state_at(at_tick: number): S {\n    const initial_tick = this.initial_tick();\n\n    if (initial_tick === null) {\n      this.reset_cache();\n      return this.init;\n    }\n\n    if (at_tick < initial_tick) {\n      return this.init;\n    }\n\n    if (this.cache_start !== initial_tick) {\n      this.state_cache.length = 0;\n      this.cache_start = initial_tick;\n    }\n\n    const timeline   = this.build_timeline();\n    let state: S     = this.init;\n    let start_tick   = initial_tick;\n\n    if (this.cache_start !== null && this.state_cache.length > 0) {\n      const highest_cached_tick = this.cache_start + this.state_cache.length - 1;\n      const usable_cached_tick  = Math.min(highest_cached_tick, at_tick);\n      const cache_index         = usable_cached_tick - this.cache_start;\n      if (cache_index >= 0) {\n        state      = this.state_cache[cache_index];\n        start_tick = usable_cached_tick + 1;\n        if (start_tick > at_tick) {\n          return state;\n        }\n      }\n    }\n\n    for (let tick = start_tick; tick <= at_tick; tick++) {\n      state = this.on_tick(state);\n\n      const posts = timeline.get(tick) || [];\n      for (const post of posts) {\n        state = this.on_post(post.data, state);\n      }\n\n      if (this.cache_start !== null) {\n        const cacheIndex = tick - this.cache_start;\n        if (cacheIndex === this.state_cache.length) {\n          this.state_cache.push(state);\n        } else if (cacheIndex >= 0 && cacheIndex < this.state_cache.length) {\n          this.state_cache[cacheIndex] = state;\n        }\n      }\n    }\n\n    return state;\n  }\n\n  // Post data to the room\n  post(data: P): void {\n    const name = client.post(this.room, data);\n    const t    = this.server_time();\n\n    const local_post: Post<P> = {\n      room:        this.room,\n      index:       -1,\n      server_time: t,\n      client_time: t,\n      name,\n      data\n    };\n\n    this.local_posts.set(name, local_post);\n    this.invalidate_cache(this.official_tick(local_post));\n  }\n\n  compute_current_state(): S {\n    return this.compute_state_at(this.server_tick());\n  }\n}\n", "{\n  \"name\": \"vibi\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"check\": \"tsc --target esnext --noEmit --skipLibCheck\",\n    \"dev\": \"bun run index.ts\",\n    \"server\": \"bun run src/server.ts\",\n    \"client\": \"bun run client_cli.ts\",\n    \"deploy\": \"bash scripts/deploy.sh\"\n  },\n  \"dependencies\": {\n    \"ws\": \"^8.18.0\"\n  },\n  \"devDependencies\": {\n    \"@types/ws\": \"^8.5.13\"\n  }\n}\n", "import { Vibi } from \"../src/vibi.ts\";\nimport { on_sync, ping, gen_name } from \"../src/client.ts\";\nimport pkg from \"../package.json\" assert { type: \"json\" };\n\n// Player type\ntype Player = {\n  px: number;\n  py: number;\n  w: number;\n  a: number;\n  s: number;\n  d: number;\n};\n\n// Game state: map from character to player\ntype GameState = {\n  [char: string]: Player;\n};\n\n// Post types\ntype GamePost =\n  | { $: \"spawn\"; nick: string; px: number; py: number }\n  | { $: \"down\"; key: \"w\" | \"a\" | \"s\" | \"d\"; player: string }\n  | { $: \"up\"; key: \"w\" | \"a\" | \"s\" | \"d\"; player: string };\n\n// Game configuration\nconst TICK_RATE         = 24; // ticks per second\nconst TOLERANCE         = 10; // milliseconds (correct this)\nconst PIXELS_PER_SECOND = 200;\nconst PIXELS_PER_TICK   = PIXELS_PER_SECOND / TICK_RATE;\nconst WORLD_WIDTH       = 1920;  // logical world width in pixels\nconst WORLD_HEIGHT      = 1080;  // logical world height in pixels\nconst PLAYER_MARGIN     = 12;    // keep the glyph fully visible\n\n// Initial state: empty map\nconst initial: GameState = {};\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value));\n}\n\n// on_tick: update player positions based on WASD state\nfunction on_tick(state: GameState): GameState {\n  const new_state: GameState = {};\n\n  for (const [char, player] of Object.entries(state)) {\n    const next_px = player.px + (player.d * PIXELS_PER_TICK) + (player.a * -PIXELS_PER_TICK);\n    const next_py = player.py + (player.s * PIXELS_PER_TICK) + (player.w * -PIXELS_PER_TICK);\n\n    new_state[char] = {\n      px: clamp(next_px, PLAYER_MARGIN, WORLD_WIDTH  - PLAYER_MARGIN),\n      py: clamp(next_py, PLAYER_MARGIN, WORLD_HEIGHT - PLAYER_MARGIN),\n      w: player.w,\n      a: player.a,\n      s: player.s,\n      d: player.d,\n    };\n  }\n\n  return new_state;\n}\n\n// on_post: handle player commands\nfunction on_post(post: GamePost, state: GameState): GameState {\n  switch (post.$) {\n    case \"spawn\": {\n      // Ignore duplicate spawns for a player that's already in the state so we\n      // don't rewind their position when they reconnect.\n      if (state[post.nick]) {\n        return state;\n      }\n\n      const player = {\n        px: clamp(post.px, PLAYER_MARGIN, WORLD_WIDTH  - PLAYER_MARGIN),\n        py: clamp(post.py, PLAYER_MARGIN, WORLD_HEIGHT - PLAYER_MARGIN),\n        w: 0,\n        a: 0,\n        s: 0,\n        d: 0\n      };\n      return { ...state, [post.nick]: player };\n    }\n    case \"down\": {\n      const updated = { ...state[post.player], [post.key]: 1 };\n      return { ...state, [post.player]: updated };\n    }\n    case \"up\": {\n      const updated = { ...state[post.player], [post.key]: 0 };\n      return { ...state, [post.player]: updated };\n    }\n  }\n  return state;\n}\n\n// Create and export game function\nexport function create_game(room: string, smooth: (past: GameState, curr: GameState) => GameState) {\n  return new Vibi<GameState, GamePost>(room, initial, on_tick, on_post, smooth, TICK_RATE, TOLERANCE);\n}\n\n// ---- App bootstrap (no JS in HTML) ----\nconst canvas: HTMLCanvasElement = document.getElementById(\"game\") as HTMLCanvasElement;\nconst ctx = canvas.getContext(\"2d\")!;\n\nfunction resize_canvas() {\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n}\nresize_canvas();\nwindow.addEventListener(\"resize\", resize_canvas);\n\nlet room = prompt(\"Enter room name:\");\nif (!room) room = gen_name();\n\nconst nick = prompt(\"Enter your nickname (single character):\");\nif (!nick || nick.length !== 1) {\n  alert(\"Nickname must be exactly one character!\");\n  throw new Error(\"Nickname must be one character\");\n}\n\nconsole.log(\"[GAME] Room:\", room, \"Nick:\", nick);\n\nconst smooth = (past: GameState, curr: GameState): GameState => {\n  if (curr[nick]) {\n    past[nick] = curr[nick];\n  }\n  return past;\n};\n\nconst game: Vibi<GameState, GamePost> = create_game(room, smooth);\ndocument.title = `Walkers ${pkg.version}`;\n\nconst key_states: Record<string, boolean> = { w: false, a: false, s: false, d: false };\n\non_sync(() => {\n  const spawn_x = 200;\n  const spawn_y = 200;\n  console.log(`[GAME] Synced; spawning '${nick}' at (${spawn_x},${spawn_y})`);\n  game.post({ $: \"spawn\", nick: nick, px: spawn_x, py: spawn_y });\n\n  const valid_keys = new Set([\"w\", \"a\", \"s\", \"d\"]);\n\n  function handle_key_event(e: KeyboardEvent) {\n    const key     = e.key.toLowerCase();\n    const is_down = e.type === \"keydown\";\n\n    if (!valid_keys.has(key)) {\n      return;\n    }\n\n    if (key_states[key] === is_down) {\n      return; // no state change (filters repeats)\n    }\n\n    key_states[key] = is_down;\n    const action = is_down ? \"down\" : \"up\";\n    game.post({ $: action, key: key as any, player: nick });\n  }\n  window.addEventListener(\"keydown\", handle_key_event);\n  window.addEventListener(\"keyup\", handle_key_event);\n\n  setInterval(render, 1000 / TICK_RATE);\n});\n\nfunction render() {\n  ctx.fillStyle = \"#fff\";\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  const curr_tick = game.server_tick();\n  const state     = game.compute_render_state();\n  const scale_x   = canvas.width / WORLD_WIDTH;\n  const scale_y   = canvas.height / WORLD_HEIGHT;\n\n  ctx.fillStyle    = \"#000\";\n  ctx.font         = \"14px monospace\";\n  ctx.textAlign    = \"left\";\n  ctx.textBaseline = \"top\";\n\n  try {\n    const st  = game.server_time();\n    const pc  = (game as any).post_count ? (game as any).post_count() : 0;\n    const rtt = ping();\n\n    ctx.fillText(`room: ${room}`, 8, 6);\n    ctx.fillText(`time: ${st}`, 8, 24);\n    ctx.fillText(`tick: ${curr_tick}`, 8, 42);\n    ctx.fillText(`post: ${pc}`, 8, 60);\n\n    if (isFinite(rtt)) {\n      ctx.fillText(`ping: ${Math.round(rtt)} ms`, 8, 78);\n    }\n  } catch {}\n\n  ctx.fillStyle    = \"#000\";\n  ctx.font         = \"24px monospace\";\n  ctx.textAlign    = \"center\";\n  ctx.textBaseline = \"middle\";\n\n  for (const [char, player] of Object.entries(state)) {\n    const x = Math.floor(player.px * scale_x);\n    const y = Math.floor(player.py * scale_y);\n    ctx.fillText(char, x, y);\n  }\n}\n"],
  "mappings": "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",
  "names": ["room", "ping", "room", "on_tick", "on_post", "smooth", "post", "server_time", "post", "room", "smooth"]
}
